"""
Automated Security Fix Bot
Takes a FixRequest, fetches file from GitHub, uses Gemini to fix vulnerability, creates PR.
"""

## NOT USING THIS FILE

import base64
import os
from dataclasses import dataclass
from datetime import datetime
from typing import Optional

import requests
from dotenv import load_dotenv
from langchain_google_genai import ChatGoogleGenerativeAI

# Load environment variables
load_dotenv()

# Configuration
GITHUB_TOKEN = os.getenv("GITHUB_TOKEN")
GOOGLE_API_KEY = os.getenv("GOOGLE_API_KEY")
GITHUB_API_BASE = "https://api.github.com"


@dataclass
class FixRequest:
    """Structure for a security fix request."""

    repo: str  # Format: "owner/repo-name"
    file_path: str  # Path to file in repo
    lines: str  # Line range e.g. "45-52"
    issue: str  # Description of the security issue
    severity: str  # HIGH, MEDIUM, LOW
    cwe: str  # Common Weakness Enumeration ID
    suggestion: str  # Suggested fix approach


class SecurityFixBot:
    """Bot that automatically fixes security vulnerabilities and creates PRs."""

    def __init__(self, github_token: str, google_api_key: str):
        """Initialize the bot with API credentials."""
        self.github_token = github_token
        self.headers = {
            "Authorization": f"Bearer {github_token}",
            "Accept": "application/vnd.github.v3+json",
        }
        self.llm = ChatGoogleGenerativeAI(
            model="gemini-pro", google_api_key=google_api_key, temperature=0.2
        )

    def fetch_file_from_github(
        self, repo: str, file_path: str
    ) -> tuple[str, str, str]:
        """
        Fetch file contents from GitHub.

        Returns:
            Tuple of (file_content, file_sha, default_branch)
        """
        print(f"üì• Fetching file: {file_path} from {repo}")

        # Get repository info to find default branch
        repo_url = f"{GITHUB_API_BASE}/repos/{repo}"
        repo_response = requests.get(repo_url, headers=self.headers)
        repo_response.raise_for_status()
        default_branch = repo_response.json()["default_branch"]

        # Get file contents
        file_url = f"{GITHUB_API_BASE}/repos/{repo}/contents/{file_path}"
        file_response = requests.get(file_url, headers=self.headers)
        file_response.raise_for_status()

        file_data = file_response.json()
        file_content = base64.b64decode(file_data["content"]).decode("utf-8")
        file_sha = file_data["sha"]

        print(f"‚úì File fetched successfully ({len(file_content)} bytes)")
        return file_content, file_sha, default_branch

    def generate_fix_with_llm(self, fix_request: FixRequest, file_content: str) -> str:
        """
        Use Gemini LLM to generate a fixed version of the file.

        Returns:
            Fixed file content as string
        """
        print(f"ü§ñ Analyzing vulnerability with Gemini...")

        # Get the problematic lines for context
        lines = file_content.split("\n")
        start_line, end_line = map(int, fix_request.lines.split("-"))
        problem_lines = "\n".join(lines[start_line - 1 : end_line])

        prompt = f"""You are a security-focused code assistant. Fix the security vulnerability in this Python file.

## Repository Context
- Repository: {fix_request.repo}
- File: {fix_request.file_path}
- Language: Python

## Security Issue
- Type: {fix_request.issue}
- Severity: {fix_request.severity}
- CWE: {fix_request.cwe}
- Lines: {fix_request.lines}
- Suggested Fix: {fix_request.suggestion}

## Current Complete File Content
```python
{file_content}
```

## Problematic Section (lines {fix_request.lines})
```python
{problem_lines}
```

## Task
Generate the COMPLETE fixed version of the file with the vulnerability patched.

Requirements:
1. Fix ONLY the security issue - don't refactor unrelated code
2. Maintain exact file structure, formatting, and indentation
3. Add a brief comment near the fix explaining what was changed
4. Ensure the fix follows Python security best practices
5. Keep all other code exactly as it was

## Output Format
Return ONLY the complete fixed file content with no explanations.
Do NOT use markdown code fences.
Start with the first line of the file and end with the last line.
"""

        response = self.llm.invoke(prompt)
        fixed_content = response.content.strip()

        # Clean up any markdown formatting if present
        if fixed_content.startswith("```python"):
            fixed_content = fixed_content.replace("```python\n", "", 1)
            fixed_content = fixed_content.rstrip("`").rstrip()
        elif fixed_content.startswith("```"):
            fixed_content = fixed_content.replace("```\n", "", 1)
            fixed_content = fixed_content.rstrip("`").rstrip()

        print(f"‚úì Fix generated ({len(fixed_content)} bytes)")
        return fixed_content

    def create_branch(self, repo: str, base_branch: str, new_branch_name: str) -> str:
        """
        Create a new branch in the repository.

        Returns:
            Branch name that was created
        """
        print(f"üîÄ Creating branch: {new_branch_name}")

        # Get the SHA of the latest commit on base branch
        ref_url = f"{GITHUB_API_BASE}/repos/{repo}/git/ref/heads/{base_branch}"
        ref_response = requests.get(ref_url, headers=self.headers)
        ref_response.raise_for_status()
        latest_commit_sha = ref_response.json()["object"]["sha"]

        # Create new branch
        create_ref_url = f"{GITHUB_API_BASE}/repos/{repo}/git/refs"
        create_ref_data = {
            "ref": f"refs/heads/{new_branch_name}",
            "sha": latest_commit_sha,
        }
        create_response = requests.post(
            create_ref_url, headers=self.headers, json=create_ref_data
        )
        create_response.raise_for_status()

        print(f"‚úì Branch created: {new_branch_name}")
        return new_branch_name

    def commit_file(
        self,
        repo: str,
        file_path: str,
        content: str,
        branch: str,
        file_sha: str,
        commit_message: str,
    ) -> str:
        """
        Commit a file to a specific branch.

        Returns:
            Commit SHA
        """
        print(f"üíæ Committing file to branch: {branch}")

        # Encode content to base64
        content_encoded = base64.b64encode(content.encode()).decode()

        # Update file
        file_url = f"{GITHUB_API_BASE}/repos/{repo}/contents/{file_path}"
        commit_data = {
            "message": commit_message,
            "content": content_encoded,
            "branch": branch,
            "sha": file_sha,
        }

        commit_response = requests.put(file_url, headers=self.headers, json=commit_data)
        commit_response.raise_for_status()

        commit_sha = commit_response.json()["commit"]["sha"]
        print(f"‚úì File committed (SHA: {commit_sha[:7]})")
        return commit_sha

    def create_pull_request(
        self, repo: str, head_branch: str, base_branch: str, fix_request: FixRequest
    ) -> str:
        """
        Create a pull request.

        Returns:
            PR URL
        """
        print(f"üîÉ Creating pull request...")

        title = f"üîí Security Fix: {fix_request.issue}"
        body = f"""## Security Vulnerability Fixed

**File:** `{fix_request.file_path}`  
**Lines:** {fix_request.lines}  
**Severity:** {fix_request.severity}  
**CWE:** {fix_request.cwe}

### Issue Description
{fix_request.issue}

### Changes Made
- {fix_request.suggestion}
- Added security fix to address {fix_request.cwe}

### Testing
Please review the changes and test thoroughly before merging.

---
*This PR was automatically generated by SecurityFixBot*
"""

        pr_url = f"{GITHUB_API_BASE}/repos/{repo}/pulls"
        pr_data = {"title": title, "head": head_branch, "base": base_branch, "body": body}

        pr_response = requests.post(pr_url, headers=self.headers, json=pr_data)
        pr_response.raise_for_status()

        pr_html_url = pr_response.json()["html_url"]
        pr_number = pr_response.json()["number"]

        print(f"‚úì Pull request created: #{pr_number}")
        print(f"üîó URL: {pr_html_url}")
        return pr_html_url

    def process_fix_request(self, fix_request: FixRequest) -> dict:
        """
        Main workflow: Process a fix request end-to-end.

        Returns:
            Dictionary with results including PR URL
        """
        print("=" * 60)
        print(f"üöÄ Processing Fix Request")
        print(f"   Repo: {fix_request.repo}")
        print(f"   File: {fix_request.file_path}")
        print(f"   Issue: {fix_request.issue}")
        print("=" * 60)

        try:
            # Step 1: Fetch file from GitHub
            file_content, file_sha, default_branch = self.fetch_file_from_github(
                fix_request.repo, fix_request.file_path
            )

            # Step 2: Generate fix with LLM
            fixed_content = self.generate_fix_with_llm(fix_request, file_content)

            # Step 3: Create new branch
            timestamp = datetime.now().strftime("%Y%m%d-%H%M%S")
            branch_name = f"fix/sql-injection-{timestamp}"
            self.create_branch(fix_request.repo, default_branch, branch_name)

            # Step 4: Commit the fixed file
            commit_message = f"Fix: {fix_request.issue} in {fix_request.file_path}"
            self.commit_file(
                fix_request.repo,
                fix_request.file_path,
                fixed_content,
                branch_name,
                file_sha,
                commit_message,
            )

            # Step 5: Create pull request
            pr_url = self.create_pull_request(
                fix_request.repo, branch_name, default_branch, fix_request
            )

            print("=" * 60)
            print("‚úÖ SUCCESS: Fix request completed!")
            print("=" * 60)

            return {
                "success": True,
                "pr_url": pr_url,
                "branch": branch_name,
                "commit_message": commit_message,
            }

        except Exception as e:
            print("=" * 60)
            print(f"‚ùå ERROR: {str(e)}")
            print("=" * 60)
            return {"success": False, "error": str(e)}


def main():
    """Main execution function with example FixRequest."""

    # Validate API keys are set
    if not GITHUB_TOKEN:
        print("‚ùå Error: GITHUB_TOKEN not found in environment variables")
        print("Please create a .env file with your GitHub token")
        return

    if not GOOGLE_API_KEY:
        print("‚ùå Error: GOOGLE_API_KEY not found in environment variables")
        print("Please create a .env file with your Google API key")
        return

    # Create a fake FixRequest for testing
    fake_fix_request = FixRequest(
        repo="OWNER/REPO-NAME",  # Replace with your test repo
        file_path="src/auth/login.py",  # Replace with actual file path
        lines="15-20",  # Replace with actual line numbers
        issue="SQL injection vulnerability - user input not sanitized",
        severity="HIGH",
        cwe="CWE-89",
        suggestion="Use parameterized queries instead of string concatenation",
    )

    # Initialize bot and process request
    bot = SecurityFixBot(GITHUB_TOKEN, GOOGLE_API_KEY)
    result = bot.process_fix_request(fake_fix_request)

    # Print results
    if result["success"]:
        print(f"\nüéâ Pull Request created successfully!")
        print(f"üîó View PR: {result['pr_url']}")
    else:
        print(f"\n‚ùå Failed to create PR: {result['error']}")


if __name__ == "__main__":
    main()
